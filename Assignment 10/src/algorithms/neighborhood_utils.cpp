#include "neighborhood_utils.h"
#include "inter_node_exchange.h"
#include "intra_edge_exchange.h"
#include "local_search.h" // For NeighbourhoodType enum
#include <stdexcept>
#include <algorithm>

/**
 * @brief Generates parameters for an inter-route node exchange move.
 *
 * This function maps a linear iterator to a specific inter-route move.
 * The move consists of swapping a node inside the solution with a node outside the solution.
 *
 * @param not_in_solution A list of node IDs not currently in the solution.
 * @param solution_pos A list of positions (indices) of nodes in the solution.
 * @param inter_iterator The linear iterator for inter-route moves.
 * @param solution_size The size of the current solution.
 * @return A vector containing {position of node to be replaced in solution, ID of replacing node, position of replacing node in not_in_solution}.
 */
std::vector<int> get_inter_node_exchange(
    std::vector<int>& not_in_solution,
    std::vector<int>& solution_pos,
    int inter_iterator,
    int solution_size
){
    // Use solution_size for modulo, not_in_solution.size() for division
    // This pairs each node in solution with each node not in solution
    int position_of_node_to_be_replaced = solution_pos[inter_iterator / not_in_solution.size()];
    int position_of_replacing_node = inter_iterator % not_in_solution.size();
    int id_of_replacing_node = not_in_solution[position_of_replacing_node];

    std::vector<int> inter_change = {position_of_node_to_be_replaced, id_of_replacing_node, position_of_replacing_node};

    return inter_change;
}

/**
 * @brief Generates parameters for an intra-route edge exchange move.
 *
 * This function maps a linear iterator to a pair of node indices for a 2-opt move.
 * It iterates through all unique pairs of edges. The number of pairs is N*(N-1)/2.
 *
 * @param i The linear iterator for intra-route edge exchange moves.
 * @param solution_size The size of the current solution.
 * @return A vector {index1, index2} which should be used to index into the shuffled solution_pos vector.
 */
std::vector<int> get_intra_edge_exchange(int i, int solution_size) {
    if (solution_size < 2) throw std::invalid_argument("Vector must have at least 2 elements for edge exchange");

    int totalPairs = solution_size * (solution_size - 1) / 2;
    if (i < 0 || i >= totalPairs)
        throw std::out_of_range("Index i is out of range for edge exchange");

    // This algorithm decodes a flat index 'i' into a pair of indices (row, col)
    // representing the strict upper triangle of a symmetric matrix (where row < col).
    int row = 0;
    while (i >= (solution_size - 1 - row)) {
        i -= (solution_size - 1 - row);
        row++;
    }
    int col = row + 1 + i;

    return {row, col}; // Return the *indices*
}

/**
 * @brief Applies a given move to the solution.
 *
 * Modifies the solution vector and the list of nodes not in the solution according to the specified move.
 *
 * @param intra_or_inter The type of neighborhood (INTRA or INTER).
 * @param solution The solution vector (modified in-place).
 * @param change The parameters for the move, generated by a get_*_exchange function.
 * @param not_in_solution The list of nodes not in the solution (modified in-place for INTER moves).
 */
void apply_change(
    NeighbourhoodType intra_or_inter,
    std::vector<int>& solution,
    const std::vector<int>& change,
    std::vector<int>& not_in_solution
){
    if (intra_or_inter == NeighbourhoodType::INTRA){
        // EDGES_EXCHANGE
        // change[0] = pos1, change[1] = pos2
        apply_intra_edge_exchange(solution, change[0], change[1]);
    } else {
        // Switch the node in solution with the node that is not used according to the change
        // change[0] = position of replaced node in solution
        // change[1] = id of replacing node
        // change[2] = position of replacing node in not_in_solution
        not_in_solution[change[2]] = solution[change[0]];
        solution[change[0]] = change[1];
    }
}
